using System;
using System.Collections.Generic;
using System.Linq;
using System.Drawing;

using Grasshopper.Kernel;
using Rhino.Geometry;
using Axis.Targets;
using Axis.Tools;

namespace Axis.Core
{
    public class Kinematics : GH_Component
    {
        // Inverse and forward kinematics for a six-axis ABB robot.

        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                return Properties.Resources.iconCore;
            }
        }
        public override Guid ComponentGuid
        {
            get { return new Guid("{1d458edc-6470-4373-9851-439ea99f4a1f}"); }
        }

        public Kinematics() : base("Kinematics", "Kinematics", "Inverse and forward kinematics solutions for six-axes.", "Axis", "Core")
        {
        }

        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddGenericParameter("Program", "Program", "Robotic toolpath for inverse kinematics.", GH_ParamAccess.item);
            pManager.AddGenericParameter("Robot", "Robot", "Robot to use for inverse kinematics.", GH_ParamAccess.item);
            pManager.AddBooleanParameter("Mode", "Mode", "Kinematic mode selection. [True = Preview, False = Code Export]", GH_ParamAccess.item, true);
            pManager.AddNumberParameter("Preview", "Preview", "Slider from 0 - 1 indicating position along program to preview.", GH_ParamAccess.item, 0.000);
            pManager.AddIntegerParameter("Joint", "Joint", "Flip joints.", GH_ParamAccess.item, 0);
        }

        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddMeshParameter("Robot", "Robot", "Transformed robot mesh geometry as list.", GH_ParamAccess.list);
            pManager.AddGenericParameter("Axis Angles", "Axis Angles", "Matrix of axis angle arrays.", GH_ParamAccess.list);
            pManager.AddGenericParameter("Program", "Program", "Robot program as list of RAPID commands.", GH_ParamAccess.item);
            pManager.AddGenericParameter("IKStuff", "IKStuff", "Lists of generic IK stuff.", GH_ParamAccess.list);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            Toolpath toolpath = null;
            Manipulator robot = null;
            bool previewMode = true;
            double previewSlider = 0.000;
            int flips = 0;

            if (!DA.GetData(0, ref toolpath)) return;
            if (!DA.GetData(1, ref robot)) return;
            if (!DA.GetData(2, ref previewMode)) return;
            if (!DA.GetData(3, ref previewSlider)) return;
            if (!DA.GetData(4, ref flips)) return;

            // Get axis points from custom robot class.
            Point3d P1 = robot.AxisPoints[0];
            Point3d P2 = robot.AxisPoints[1];
            Point3d P3 = robot.AxisPoints[2];
            Point3d P4 = robot.AxisPoints[3];

            // Remap preview slider value to selection index based on toolpath length.
            double toolpathLength = toolpath.Targets.Count;
            double previewVal = previewSlider;
            double remappedValue = Util.Remap(previewVal, 0, 1, 0, toolpathLength);
            int previewIndex = Convert.ToInt32(remappedValue - 1);

            if (previewIndex == -1)
            {
                previewIndex = 0;
            }
            else if (previewIndex == toolpathLength)
            {
                previewIndex -= 1;
            }
            
            List<Target> robTargs = toolpath.Targets;

            Plane targPlane = robTargs[previewIndex].TargetPlane;
            Plane flange = new Plane(targPlane.Origin, -targPlane.XAxis, targPlane.YAxis);

            var remap = robot.InverseRemap;
            var transform = Transform.PlaneToPlane(Plane.WorldXY, robot.RobTool.TCP);

            flange.Transform(remap);
            flange.Transform(transform);
            flange.Rotate(Math.PI, flange.ZAxis);

            // DEBUG
            List<object> ikStuff = new List<object>();
            ikStuff.Add(flange);

            if (previewMode == true && robTargs[0] != null)
            {
                List<string> errors = new List<string>();

                bool isUnreachable = false;
                bool shoulder = false;
                bool elbow = false;
                bool wrist = false;

                // Flip joints.
                if (flips == 1)
                {
                    shoulder = true;
                }
                else if (flips == 2)
                {
                    elbow = true;
                }
                if (flips == 3)
                {
                    wrist = true;
                }
                if (flips == 4)
                {
                    shoulder = true;
                    elbow = true;
                }
                if (flips == 5)
                {
                    elbow = true;
                    wrist = true;
                }
                if (flips == 6)
                {
                    shoulder = true;
                    wrist = true;
                }

                double[] a = robot.JointA.ToArray();
                double[] d = robot.JointD.ToArray();

                double[] joints = new double[6];

                double l2 = Math.Sqrt(a[2] * a[2] + d[3] * d[3]);
                double ad2 = Math.Atan2(a[2], d[3]);
                Point3d center = flange.Origin - flange.Normal * d[5];
                ikStuff.Add(center);
                joints[0] = Math.Atan2(center.Y, center.X);
                double ll = Math.Sqrt(center.X * center.X + center.Y * center.Y);
                Point3d p1 = new Point3d(a[0] * center.X / ll, a[0] * center.Y / ll, d[0]);

                if (shoulder == true)
                {
                    joints[0] += Math.PI;
                    var rotate = Transform.Rotation(Math.PI, new Point3d(0, 0, 0));
                    center.Transform(rotate);
                }

                double l3 = (center - p1).Length;
                double l1 = a[1];
                double beta = Math.Acos((l1 * l1 + l3 * l3 - l2 * l2) / (2 * l1 * l3));
                if (double.IsNaN(beta))
                {
                    beta = 0;
                    isUnreachable = true;
                }
                if (elbow)
                    beta *= -1;

                double ttl = new Vector3d(center.X - p1.X, center.Y - p1.Y, 0).Length;
                // if (p1.X * (center.X - p1.X) < 0)
                if (shoulder)
                    ttl = -ttl;
                double al = Math.Atan2(center.Z - p1.Z, ttl);

                joints[1] = beta + al;

                double gama = Math.Acos((l1 * l1 + l2 * l2 - l3 * l3) / (2 * l1 * l2));
                if (double.IsNaN(gama))
                {
                    gama = Math.PI;
                    isUnreachable = true;
                }
                if (elbow)
                    gama *= -1;

                joints[2] = gama - ad2 - Math.PI / 2;

                double[] c = new double[3];
                double[] s = new double[3];
                for (int i = 0; i < 3; i++)
                {
                    c[i] = Math.Cos(joints[i]);
                    s[i] = Math.Sin(joints[i]);
                }

                var arr = new Transform();
                arr[0, 0] = c[0] * (c[1] * c[2] - s[1] * s[2]); arr[0, 1] = s[0]; arr[0, 2] = c[0] * (c[1] * s[2] + s[1] * c[2]); arr[0, 3] = c[0] * (a[2] * (c[1] * c[2] - s[1] * s[2]) + a[1] * c[1]) + a[0] * c[0];
                arr[1, 0] = s[0] * (c[1] * c[2] - s[1] * s[2]); arr[1, 1] = -c[0]; arr[1, 2] = s[0] * (c[1] * s[2] + s[1] * c[2]); arr[1, 3] = s[0] * (a[2] * (c[1] * c[2] - s[1] * s[2]) + a[1] * c[1]) + a[0] * s[0];
                arr[2, 0] = s[1] * c[2] + c[1] * s[2]; arr[2, 1] = 0; arr[2, 2] = s[1] * s[2] - c[1] * c[2]; arr[2, 3] = a[2] * (s[1] * c[2] + c[1] * s[2]) + a[1] * s[1] + d[0];
                arr[3, 0] = 0; arr[3, 1] = 0; arr[3, 2] = 0; arr[3, 3] = 1;

                var in123 = new Transform();
                arr.TryGetInverse(out in123);

                var mr = Transform.Multiply(in123, transform);
                joints[3] = Math.Atan2(mr[1, 2], mr[0, 2]);
                joints[4] = Math.Acos(mr[2, 2]);
                joints[5] = Math.Atan2(mr[2, 1], -mr[2, 0]);

                if (wrist)
                {
                    joints[3] += Math.PI;
                    joints[4] *= -1;
                    joints[5] -= Math.PI;
                }

                for (int i = 0; i < 6; i++)
                {
                    if (joints[i] > Math.PI) joints[i] -= 2 * Math.PI;
                    if (joints[i] < -Math.PI) joints[i] += 2 * Math.PI;
                }

                if (isUnreachable)
                    errors.Add($"Target out of reach");

                if (Math.Abs(1 - mr[2, 2]) < 0.0001)
                    errors.Add($"Near wrist singularity");

                if (new Vector3d(center.X, center.Y, 0).Length < a[0] + 0.01)
                    errors.Add($"Near overhead singularity");


                for (int i = 0; i < 6; i++)
                {
                    if (double.IsNaN(joints[i])) joints[i] = 0;
                }

                // Correction values
                joints[1] = joints[1] - (Math.PI / 2);
                joints[2] = joints[2] + (Math.PI / 2);
                joints[4] = joints[4] - (Math.PI / 2);

                List<double> jointsDegrees = new List<double>();
                for (int i = 0; i < 6; i++)
                {
                    jointsDegrees.Add((joints[i] * 180 / Math.PI));
                }
            
                List<Plane> axisPlanes = new List<Plane>();
                for (int i = 0; i < robot.AxisPlanes.Count; i++)
                {
                    Plane tempPlane = new Plane(robot.AxisPlanes[i].Origin, robot.AxisPlanes[i].XAxis, robot.AxisPlanes[i].YAxis);
                    axisPlanes.Add(tempPlane);
                }

                // Reference our input meshes, and create a new list of manipulatable meshes that will act as our output meshes.
                List<Mesh> robotMeshes = new List<Mesh>();

                for (int i = 0; i < robot.IKMeshes.Count; i++)
                {
                    Mesh tempMesh = new Mesh();
                    tempMesh = robot.IKMeshes[i].DuplicateMesh();
                    robotMeshes.Add(tempMesh);
                }

                // Rotation set one.
                Transform Rotation1 = Transform.Rotation(joints[0], robot.RobBasePlane.ZAxis, robot.RobBasePlane.Origin);
                for (int j = 1; j < robotMeshes.Count; j++)
                {
                    robotMeshes[j].Transform(Rotation1);
                }

                for (int j = 0; j < axisPlanes.Count; j++)
                {
                    //Plane tempPlane = axisPlanes[j];
                    Plane tempPlane = new Plane(axisPlanes[j].Origin, axisPlanes[j].XAxis, axisPlanes[j].YAxis);
                    tempPlane.Transform(Rotation1);
                    axisPlanes[j] = tempPlane;
                }

                // Rotation set two.
                Transform Rotation2 = Transform.Rotation(joints[1], axisPlanes[0].ZAxis, axisPlanes[0].Origin);
                for (int j = 2; j < robotMeshes.Count; j++)
                {
                    robotMeshes[j].Transform(Rotation2);
                }

                for (int j = 1; j < axisPlanes.Count; j++)
                {
                    Plane tempPlane = new Plane(axisPlanes[j].Origin, axisPlanes[j].XAxis, axisPlanes[j].YAxis);
                    tempPlane.Transform(Rotation2);
                    axisPlanes[j] = tempPlane;
                }

                // Rotation set three.
                Transform Rotation3 = Transform.Rotation(joints[2], axisPlanes[1].ZAxis, axisPlanes[1].Origin);
                for (int j = 3; j < robotMeshes.Count; j++)
                {
                    robotMeshes[j].Transform(Rotation3);
                }
                for (int j = 2; j < axisPlanes.Count; j++)
                {
                    Plane tempPlane = new Plane(axisPlanes[j].Origin, axisPlanes[j].XAxis, axisPlanes[j].YAxis);
                    tempPlane.Transform(Rotation3);
                    axisPlanes[j] = tempPlane;
                }

                // Rotation set four.
                Transform Rotation4 = Transform.Rotation(joints[3], axisPlanes[2].ZAxis, axisPlanes[2].Origin);
                for (int j = 4; j < robotMeshes.Count; j++)
                {
                    robotMeshes[j].Transform(Rotation4);
                }
                for (int j = 3; j < axisPlanes.Count; j++)
                {
                    Plane tempPlane = new Plane(axisPlanes[j].Origin, axisPlanes[j].XAxis, axisPlanes[j].YAxis);
                    tempPlane.Transform(Rotation4);
                    axisPlanes[j] = tempPlane;
                }

                // Rotation set five.
                Transform Rotation5 = Transform.Rotation(joints[4], axisPlanes[3].ZAxis, axisPlanes[3].Origin);
                for (int j = 5; j < robotMeshes.Count; j++)
                {
                    robotMeshes[j].Transform(Rotation5);
                }
                for (int j = 4; j < axisPlanes.Count; j++)
                {
                    Plane tempPlane = new Plane(axisPlanes[j].Origin, axisPlanes[j].XAxis, axisPlanes[j].YAxis);
                    tempPlane.Transform(Rotation5);
                    axisPlanes[j] = tempPlane;
                }

                // Rotation set six.
                Transform Rotation6 = Transform.Rotation(joints[5], axisPlanes[4].ZAxis, axisPlanes[4].Origin);
                for (int j = 6; j < robotMeshes.Count; j++)
                {
                    robotMeshes[j].Transform(Rotation6);
                }
                for (int j = 5; j < axisPlanes.Count; j++)
                {
                    Plane tempPlane = new Plane(axisPlanes[j].Origin, axisPlanes[j].XAxis, axisPlanes[j].YAxis);
                    tempPlane.Transform(Rotation6);
                    axisPlanes[j] = tempPlane;
                }

                // Output robot mesh preview geometry, as well as a list of the resultant joint angles.
                DA.SetDataList(0, robotMeshes);
                DA.SetData(1, jointsDegrees);
                DA.SetDataList(3, ikStuff);
            }
        }
    }
}